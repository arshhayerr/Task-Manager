// Sort tasks: incomplete first, then by priority (high > medium > low), then by creation date (newest first)
const priorityOrder = { high: 3, medium: 2, low: 1 };
filteredTasks.sort((a, b) =>
    a.completed - b.completed ||
    (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0) ||
    b.id - a.id
);

filteredTasks.forEach(task => ){
    const li = document.createElement('li');
    li.className = task-item flex items-center justify-between p-3 rounded-lg shadow-sm border border-[var(--border-color)] bg-[var(--bg-primary)] ${task.completed ? 'completed' : 'hover:bg-[var(--bg-secondary)]'};
    li.dataset.id = task.id;

    const taskContent = document.createElement('div');
    taskContent.className = 'flex-grow mr-3 overflow-hidden';

    if (task.isEditing) {
        // --- Editing State ---
         // (Code for editing inputs - unchanged from previous version)
        const editInput = document.createElement('input');
        editInput.type = 'text';
        editInput.value = task.description;
        editInput.className = 'editing-input task-edit-description w-full sm:w-3/4 mb-1';
        editInput.required = true;

        const editDeadline = document.createElement('input');
        editDeadline.type = 'date';
        editDeadline.value = task.deadline || '';
        editDeadline.className = 'editing-input task-edit-deadline w-auto text-xs mt-1';

        taskContent.appendChild(editInput);
        taskContent.appendChild(editDeadline);
        setTimeout(() => editInput.focus(), 0);

    } else {
        // --- Display State ---
        const descriptionSpan = document.createElement('span');
        descriptionSpan.textContent = task.description;
        descriptionSpan.className = break-words ${task.completed ? 'completed-text' : ''};

    }}